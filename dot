#!/bin/sh

# Directory definition
declare -a user_dirs=(home config scripts)
declare -a sys_dirs=(etc)
declare -A sync_dirs=(
	[home]=$HOME
	[config]=$HOME/.config
	[scripts]=$HOME/scripts
	[etc]=/etc
)

# Supported arguments
declare -A args=(
	[user]=0
	[sys]=0
	[clean]=0
)

# Environment check
if [[ -z "$DOT_REPO" ]]; then
	echo -e "\e[31m\$DOT_REPO not set. Use default \$HOME/dotfiles\e[0m"
	DOT_REPO=$HOME/dotfiles
fi

if [ ! -d $DOT_REPO ]; then
	echo "\$DOT_REPO ($DOT_REPO) directory not found."
	echo "Please check your install location."
	exit 1
fi

# Help message
usage() {
	echo -e "\e[1;34mUSAGE\e[0m dot [all|user|system|clean|help|status|diff] [-v|--verbose] [-p|--pretend]"
}

help_msg() {
	echo -e "\e[1mdot - Dotfile manager\e[0m"
	usage
	echo ""
	echo -e "\e[1;34mARGUMENTS         DESCRIPTION\e[0m"
	echo "(No argument)     Equal to \`dot all\`"
	echo "a|all             Update user and system configuration"
	echo "u|user            Update user dotfile"
	echo "s|sys|system      Update system config files"
    echo "c|clean           Delete all dotfiles (\`dot clean [all|user|system]\`)"
	echo "h|help            Display this help message"
	echo "t|status          Display repo status info"
	echo "d|diff            Display repo diff info"
	echo ""
	echo -e "\e[1;34mOPTIONS           DESCRIPTION\e[0m"
	echo "-p|--pretend      Fake run, not affecting real filesystem"
	echo "-v|--verbose      Verbose output"
	echo "-n|--no-backup    Don't backup existing files"
	echo "-r|--recover      Recover files in backup directory when cleaning"
}

# Processing arguments
cmd_cnt=0
verbose=0
pretend=0
nobackup=0
recover=0

git_cmd="git --git-dir=$DOT_REPO/.git --work-tree=$DOT_REPO"

if [ $# -eq 0 ]; then
	args[user]=1
	args[sys]=1
	((cmd_cnt += 2))
else
	while [ $# -gt 0 ]; do
		case $1 in
		a | all)
			args[user]=1
			args[sys]=1
			((cmd_cnt += 2))
			shift
			;;
		u | user)
			args[user]=1
			((cmd_cnt++))
			shift
			;;
		s | sys | system)
			args[sys]=1
			((cmd_cnt++))
			shift
			;;
		c | clean)
			args[clean]=1
			((cmd_cnt++))
			shift
			;;
		-v | --verbose)
			verbose=1
			shift
			;;
		-p | --pretend)
			pretend=1
			shift
			;;
		-n | --no-backup)
			nobackup=1
			shift
			;;
		-r | --recover)
			recover=1
			shift
			;;
		h | help)
			help_msg
			exit 0
			;;
		t | status)
			$git_cmd status
			exit 0
			;;
		d | diff)
			$git_cmd diff
			exit 0
			;;
		*)
			echo "INVALID ARGUMENT $1"
			usage
			exit 1
			;;
		esac
	done
fi

if [ $cmd_cnt -eq 0 ]; then
	args[user]=1
	args[sys]=1
	cmd_cnt=2
fi

if test $verbose -eq 1; then
	echo ""
	echo "Checking commands"
	for cmd in ${!args[@]}; do
		if test ${args[$cmd]} -eq 1; then
			echo "$cmd enabled"
		else
			echo "$cmd disabled"
		fi
	done
	echo "$cmd_cnt commands in total."
	echo ""
fi

# Update functions
LN="ln -svf"
MV="mv -v"
MD="mkdir -pv"
RM="rm -v"

total_files=0

# $1: repo dir $2: 1:show, 0:proceed $3: sudo
update_dir() {
	files=($(find $DOT_REPO/$1 -type f))
	((total_files += ${#files[@]}))
	for f in ${files[@]}; do
		repo_file=$f
		real_file=${sync_dirs[$1]}/${f#$DOT_REPO/$1/}
		real_dir=$(dirname $real_file)
		backup_file=$DOT_REPO/.backup/${f#$DOT_REPO/}
		backup_dir=$(dirname $backup_file)
		sudo=$3

		# Clean
		if [ ${args[clean]} -eq 1 ]; then
			if test $2 -eq 1; then
				echo "[RM] $real_file"
				if test $recover -eq 1 && test -f $backup_file; then
					echo "[MV] $backup_file $real_file"
				fi
			else
				$sudo $RM $real_file
				if test $recover -eq 1 && test -f $backup_file; then
					$sudo $MV $backup_file $real_file
				fi
			fi
			continue
		fi

		# Update file
		if ! (test -f $real_file || test -d $real_file || test -L $real_file); then
			# file not exist
			if test $2 -eq 1; then
				test $verbose -eq 1 && (test -d $real_dir || echo "[MD] $real_dir")
				echo "[LN] $repo_file -> $real_file"
			else
				test -d $real_dir || $sudo $MD $real_dir
				$sudo $LN $repo_file $real_file
			fi
		elif test -L $real_file && ! test $real_file -ef $repo_file; then
			# real_file is a link and not pointing to repo_file
			if test $2 -eq 1; then
				echo "$real_file is a link pointing to $(readlink -q $real_file)"
				if [ -f $(readlink -q $real_file) ]; then
					test $verbose -eq 1 && (test -d $backup_dir || echo "[MD] $backup_dir")
					test $verbose -eq 1 && echo "[LN] $(readlink $real_file) $backup_file"
				fi
				test $verbose -eq 1 && (test -d $real_dir || echo "[MD] $real_dir")
				echo "[LN] $repo_file -> $real_file"
			else
				if [ -f $(readlink -q $real_file) ]; then
					test -d $backup_dir || $MD $backup_dir
					$sudo $LN $(readlink $real_file) $backup_file
				fi
				test -d $real_dir || $sudo $MD $real_dir
				$sudo $LN $repo_file $real_file
			fi
		elif test -f $real_file && ! test $real_file -ef $repo_file; then
			# file exists
			if test $2 -eq 1; then
				if test $verbose -eq 1; then
					test -d $backup_dir || echo "[MD] $backup_dir"
					echo "[MV] $real_file -> $backup_file"
					test -d $real_dir || echo "[MD] $real_dir"
				fi
				echo "[LN] $repo_file -> $real_file"
			else
				test -d $backup_dir || $MD $backup_dir
				$sudo $MV $real_file $backup_file
				test -d $real_dir || $sudo $MD $real_dir
				$sudo $LN $repo_file $real_file
			fi
		elif test -L $real_file && test $real_file -ef $repo_file; then
			# already set properly
			if test $verbose -eq 1 && test $2 -eq 1; then echo "- $real_file already set proprly."; fi
			((total_files--))
		else
			# other
			if test $2 -eq 1; then
				echo "Please check status of $real_file. Skipping..."
			else
				echo "Skipping $real_file..."
			fi
		fi
	done
}

confirm() {
	while :; do
		read -p "Please confirm the above operations. Proceed? [Y/n] " -r confirm
		if [[ -z $confirm ]]; then
			echo "y"
			break
		else
			case $confirm in
			y | Y)
				echo "y"
				break
				;;
			n | N)
				echo "n"
				break
				;;
			*)
				continue
				;;
			esac
		fi
	done
}

# $1: user/sys
update() {
    case $1 in
        user)
            _dirs=(${user_dirs[@]})
            _sudo=""
            ;;
        sys)
            _dirs=(${sys_dirs[@]})
            _sudo="sudo"
            ;;
        *)
            echo "Wrong argument $1 in update"
            exit 1
            ;;
    esac
	total_files=0
	for d in $_dirs; do
		update_dir "$d" 1
	done
	echo "$total_files files to proceed."
	if test $pretend -eq 0 && [ $total_files -gt 0 ] && [[ "$(confirm)" == "y" ]]; then
		for d in $_dirs; do
			update_dir "$d" 0 "$_sudo"
		done
	fi
	echo ""
}

process_hint() {
    echo -e "\e[34m==> \e[0m\e[1m$1\e[0m"
}

update_user() {
	process_hint "Updating user dotfiles"
	update user
}

update_sys() {
	process_hint "Updating system config"
	update sys
}

recover_warning=" !! All stored dotfiles will not recover automatically."

clean_user() {
	process_hint "Cleaning user dotfiles"
	test $recover -eq 1 || echo $recover_warning
	update user
}

clean_sys() {
	process_hint "Cleaning system configuration"
	test $recover -eq 1 || echo $recover_warning
	update sys
}

# Process files
if [ ${args[clean]} -eq 1 ]; then
	if [ $cmd_cnt -eq 1 ]; then
		clean_user
		clean_sys
	else
		if [ ${args[user]} -eq 1 ]; then clean_user; fi
		if [ ${args[sys]} -eq 1 ]; then clean_sys; fi
	fi
else
	if [ ${args[user]} -eq 1 ]; then update_user; fi
	if [ ${args[sys]} -eq 1 ]; then update_sys; fi
fi
